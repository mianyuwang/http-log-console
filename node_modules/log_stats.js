(() => { // namespace
'use strict';

const alertq = require('alert_queue');

const CATEGORY = "@LogStats";

class LogStats {
    /**
     * Constructor of log stats class
     * @param {Object} options 
     */
    constructor(options) {
        console.log("[INFO]", CATEGORY, "Initializing LogStats");
        // option parameters
        let defaultOptions = {
            verbose: false,
            dumpInterval:           10, // dump interval in second          
            highTrafficThresholdPS: 10, // request per second
            highTrafficSpan:       120, // how many seconds
        };
        this.options = {...options, ...defaultOptions};
        // state
        this.totalCount = 0; // total count requested
        this.totalBytes = 0; // total bytes requested
        this.lastTimestamp = null; // last processed timestamp
        this.sectionCountInterval = new Map(); // hash table of section - count
        this.statusCountInterval = new Map(); // hash table of HTTP status code - count
        
        // Recurring timer to dump stats
        this.interval = setInterval(this.print.bind(this), this.options.dumpInterval * 1000);

        // alerting
        this.alertQueue = new alertq.AlertQueue(this.options.highTrafficThresholdPS,
                                                this.options.highTrafficSpan);
        this.alertQueue.on('alert_on', data => {
            console.log("# High traffic generated an alert - hits = " + data.triggeringHits +
                        ", rate = " + data.triggeringRate + "per second, triggered at", 
                        data.triggeringTime);
        });
        this.alertQueue.on('alert_off', data => {
            console.log("# High traffic alert recovered - hits = " + data.triggeringHits +
                        ", rate = " + data.triggeringRate + "per second, triggered at", 
                        data.triggeringTime);
        });
    }
    /**
     * Dump the stats to stdout
     */
    print() {
        console.log("[INFO]", CATEGORY, "Statistics:");
        console.log("  ================================");
        console.log("  | Total Hits =", this.totalCount);
        console.log("  | Total Bytes =", this.totalBytes);
        console.log("  | Last Log Received at", this.lastTimestamp);
        let mostHit = 0, mostHitSection = "";
        for (let [key, val] of this.sectionCountInterval) {
            if (val > mostHit) {
                mostHitSection = key;
                mostHit = val;
            }
        }
        console.log("  | Section with the most hits =", mostHitSection, " hits =", mostHit);
        console.log("  --------------------------------");
        // reset the interval stat
        this.sectionCountInterval.clear();
    }
    /**
     * Ingest a single log line
     * @param {String} logline 
     */
    ingest(logline) {
        let fields = [];
        // parsing the line by regex
        logline.replace(
            /(.*) (.*) (.*) \[(.*)\] \"(.*) (.*) (.*)\" (.*) (.*)/,
            (match, ip, ident, userid, time, method, url, protocol, status, size) => {
                fields.push({
                    ip: ip,
                    ident: ident,
                    userid: userid,
                    timestr: time,
                    method: method,
                    url: url,
                    protocol: protocol,
                    status: status,
                    size: size
                });
            });
        if (fields[0] === undefined) { return; } // ignore unmatched line
        console.log("[DEBUG]", CATEGORY, "Ingesting", fields[0]);
        this.updateStats(fields[0]);
    }
    /**
     * Update stats by a new coming stat
     * @param {Object} curr stat object to be process
     */
    updateStats(curr) {
        // TODO: check overflow
        this.totalCount ++;
        this.totalBytes += curr.size;

        // Parse the timestamp string
        this.lastTimestamp = new Date(
            curr.timestr.replace(
                /(\d+)\/(\w+)\/(\d+):(\d+:\d+:\d+) ([+-=]\d+)/,
                "$2 $1 $3 $4 $5"));
        console.log("[DEBUG]", CATEGORY, "Parsing timestr", curr.timestr, "into", this.lastTimestamp);
        // and update alert
        this.alertQueue.push(this.lastTimestamp);
        
        // Section parsing after removing site domain name like http://a.b.c/
        let sections = curr.url.replace(/.*:\/\/\w+(\.\w+)+/, "").split('/'); 
        let secKey = "";
        if (sections.length >= 3) {
            secKey = sections[0] + "/" + sections[1] + "/";
        } else if (sections.length == 2) { // <root>/resource
            secKey = "/";
        } else {
            console.log("[WARN]", CATEGORY, "No section parsed from", curr.url);
        }
        let sec = this.sectionCountInterval.get(secKey);
        this.sectionCountInterval.set(secKey, sec ? (sec+1) : 1);
        
        // Status code count in a map
        let scc = this.statusCountInterval.get(curr.status);
        this.statusCountInterval.set(curr.status, scc ? (scc+1) : 1);
    }
} // class LogStats

exports.LogStats = LogStats;
})(); // close namepace
